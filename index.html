<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>QR Decoder - Detection Mode</title>
<style>
    body { 
        margin: 0;
        padding: 20px;
        font-family: Arial, sans-serif;
    }
    #container {
        position: relative;
        display: inline-block;
    }
    #video {
        display: block;
        width: 100%;
        height: 100%;
        object-fit: cover;
        border: 2px solid #ccc;
    }
    #overlay {
        position: absolute;
        top: 0;
        left: 0;
        width: 576px;   /* MUST match container */
        height: 576px;  /* MUST match container */
        pointer-events: none;
    }
    button {
        margin: 10px 5px;
        padding: 10px 20px;
    }
    #output {
        margin-top: 20px;
        padding: 10px;
        border: 1px solid #ccc;
        background: #f0f0f0;
        font-family: monospace;
        white-space: pre-wrap;
        max-height: 300px;
        overflow-y: auto;
    }
</style>
</head>
<body>

<div id="container">
    <video id="video"autoplay playsinline muted></video>
    <canvas id="overlay" width="576" height="576"></canvas>
</div>

<button onclick="startCamera()">Start Camera</button>
<button onclick="stopCamera()">Stop Camera</button>
<button onclick="toggleScan()">Toggle Scan</button>

<div id="output">Waiting to detect QR code...</div>

<script>
const video = document.getElementById('video');
const overlay = document.getElementById('overlay');
const overlayCtx = overlay.getContext('2d');
const output = document.getElementById('output');

let stream = null;
let scanning = false;
let animationId = null;

async function startCamera() {
    try {
        stream = await navigator.mediaDevices.getUserMedia({ 
            video: { facingMode: 'environment', width: 1280, height: 720 } 
        });
        video.srcObject = stream;
        output.textContent = 'Camera started. Click "Toggle Scan" to begin detection.';
    } catch (err) {
        output.textContent = 'Error accessing camera: ' + err.message;
    }
}

function stopCamera() {
    if (stream) {
        stream.getTracks().forEach(track => track.stop());
        video.srcObject = null;
        scanning = false;
        if (animationId) {
            cancelAnimationFrame(animationId);
        }
        overlayCtx.clearRect(0, 0, overlay.width, overlay.height);
        output.textContent = 'Camera stopped.';
    }
}

function toggleScan() {
    scanning = !scanning;
    if (scanning) {
        output.textContent = 'Scanning...';
        scanFrame();
    } else {
        if (animationId) {
            cancelAnimationFrame(animationId);
        }
        overlayCtx.clearRect(0, 0, overlay.width, overlay.height);
        output.textContent = 'Scanning paused.';
    }
}

function scanFrame() {
    if (!scanning) return;

    // Clear overlay
    overlayCtx.clearRect(0, 0, overlay.width, overlay.height);

    const canvas = document.createElement('canvas');
    canvas.width = video.videoWidth;
    canvas.height = video.videoHeight;
    const ctx = canvas.getContext('2d');
    
    ctx.drawImage(video, 0, 0);
    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
    
    // Try to detect the QR code
    const result = detectQRCode(imageData);
    
    if (result) {
        // Calculate scale between video display and actual video resolution
        const scaleX = overlay.width / video.videoWidth;
        const scaleY = overlay.height / video.videoHeight;
        
        output.textContent = 'QR Code detected!\n\n' + 
            'Corners found: ' + result.corners.length + '\n' +
            'Grid extracted: ' + (result.grid ? 'Yes' : 'No') + '\n';
        
        // Draw detected corners on overlay
        overlayCtx.strokeStyle = 'red';
        overlayCtx.lineWidth = 3;
        overlayCtx.fillStyle = 'red';
        overlayCtx.font = '14px Arial';
        
        result.corners.forEach((corner, idx) => {
            const x = corner.x * scaleX;
            const y = corner.y * scaleY;
            const size = (corner.size || 60) * scaleX;
            
            // Draw red rectangle around detected corner
            overlayCtx.strokeRect(x - 5, y - 5, size + 10, size + 10);
            
            // Label the corner
            const labels = ['TL', 'TR', 'BL'];
            overlayCtx.fillText(labels[idx], x, y - 10);
        });
        
        if (result.grid) {
            decodeGrid(result.grid);
        }
    } else {
        output.textContent = 'Scanning... No QR code detected yet.';
    }
    
    animationId = requestAnimationFrame(scanFrame);
}

function detectQRCode(imageData) {
    const width = imageData.width;
    const height = imageData.height;
    const data = imageData.data;
    
    // Find white squares (8x8 markers)
    const markers = findWhiteSquares(data, width, height);
    
    if (markers.length >= 3) {
        // Sort markers to identify corners
        const corners = identifyCorners(markers);
        
        if (corners.length === 3) {
            // Extract the 128x128 grid
            const grid = extractGrid(imageData, corners);
            
            return {
                corners: corners,
                grid: grid,
                data: null
            };
        }
    }
    
    return null;
}

function findWhiteSquares(data, width, height) {
    const markers = [];
    const minSize = 60; // minimum size in pixels for a marker
    const step = 10; // scan step
    
    for (let y = 0; y < height - minSize; y += step) {
        for (let x = 0; x < width - minSize; x += step) {
            if (isWhiteSquare(data, width, x, y, minSize)) {
                markers.push({ x: x, y: y, size: minSize });
            }
        }
    }
    
    return markers;
}

function isWhiteSquare(data, width, x, y, size) {
    let whiteCount = 0;
    let totalCount = 0;
    const threshold = 150; // brightness threshold
    
    for (let dy = 0; dy < size; dy += 2) {
        for (let dx = 0; dx < size; dx += 2) {
            const px = x + dx;
            const py = y + dy;
            if (px >= width || py >= width) continue;
            
            const i = (py * width + px) * 4;
            const brightness = (data[i] + data[i + 1] + data[i + 2]) / 3;
            
            if (brightness > threshold) whiteCount++;
            totalCount++;
        }
    }
    
    return (whiteCount / totalCount) > 0.6; // 60% white pixels
}

function identifyCorners(markers) {
    if (markers.length < 3) return [];
    
    // Find top-left (min x+y), top-right (max x, min y), bottom-left (min x, max y)
    let sorted = [...markers];
    sorted.sort((a, b) => (a.x + a.y) - (b.x + b.y));
    const topLeft = sorted[0];
    
    sorted = [...markers];
    sorted.sort((a, b) => (b.x - a.x) || (a.y - b.y));
    const topRight = sorted[0];
    
    sorted = [...markers];
    sorted.sort((a, b) => (a.x - b.x) || (b.y - a.y));
    const bottomLeft = sorted[0];
    
    return [topLeft, topRight, bottomLeft];
}

function extractGrid(imageData, corners) {
    const [topLeft, topRight, bottomLeft] = corners;
    
    // The white markers are OUTSIDE the 128x128 data grid
    // The data grid starts at the bottom-right of top-left marker
    const markerSize = topLeft.size || 60;
    
    const dataStartX = topLeft.x + markerSize;
    const dataStartY = topLeft.y + markerSize;
    
    // Calculate data grid dimensions
    const gridWidth = topRight.x - (topLeft.x + markerSize);
    const gridHeight = bottomLeft.y - (topLeft.y + markerSize);
    
    if (gridWidth < 50 || gridHeight < 50) return null;
    
    const SIDE = 128;
    const bits = [];
    const blockWidth = gridWidth / SIDE;
    const blockHeight = gridHeight / SIDE;
    
    for (let row = 0; row < SIDE; row++) {
        for (let col = 0; col < SIDE; col++) {
            const x = Math.floor(dataStartX + col * blockWidth + blockWidth / 2);
            const y = Math.floor(dataStartY + row * blockHeight + blockHeight / 2);
            
            if (x >= 0 && x < imageData.width && y >= 0 && y < imageData.height) {
                const i = (y * imageData.width + x) * 4;
                const brightness = (imageData.data[i] + imageData.data[i + 1] + imageData.data[i + 2]) / 3;
                bits.push(brightness < 128 ? '1' : '0');
            } else {
                bits.push('0');
            }
        }
    }
    
    return bits.join('');
}

function decodeGrid(bitString) {
    try {
        // Convert bits to bytes
        const bytes = [];
        for (let i = 0; i < bitString.length; i += 8) {
            const byte = parseInt(bitString.substr(i, 8), 2);
            bytes.push(byte);
        }
        
        // Check magic bytes "B2D1"
        const magic = String.fromCharCode(bytes[0], bytes[1], bytes[2], bytes[3]);
        
        if (magic !== 'B2D1') {
            output.textContent += '\nInvalid magic bytes: ' + magic;
            return;
        }
        
        // Extract header
        const total = (bytes[4] << 8) | bytes[5];
        const index = (bytes[6] << 8) | bytes[7];
        const length = (bytes[8] << 8) | bytes[9];
        
        // Extract data
        const chunkData = bytes.slice(10, 10 + length);
        
        // Extract CRC (last 4 bytes of chunk)
        const crcStart = 10 + length;
        const crc = (bytes[crcStart] << 24) | (bytes[crcStart + 1] << 16) | 
                    (bytes[crcStart + 2] << 8) | bytes[crcStart + 3];
        
        // Try to decode as text
        let text = '';
        for (let i = 0; i < chunkData.length; i++) {
            const byte = chunkData[i];
            if (byte >= 32 && byte <= 126) {
                text += String.fromCharCode(byte);
            } else {
                text += '.';
            }
        }
        
        output.textContent = 'Decoded successfully! ✓\n\n' +
            'Magic: ' + magic + ' ✓\n' +
            'Total chunks: ' + total + '\n' +
            'Current chunk: ' + index + '\n' +
            'Data length: ' + length + '\n' +
            'CRC: 0x' + crc.toString(16).padStart(8, '0') + '\n\n' +
            'Decoded data:\n' + text.substring(0, 500);
            
    } catch (err) {
        output.textContent += '\nDecode error: ' + err.message;
    }
}
</script>

</body>
</html>