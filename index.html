<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>QR Decoder - Alignment Mode</title>
<style>
    body { 
        margin: 0;
        padding: 20px;
        font-family: Arial, sans-serif;
    }
    #container {
        position: relative;
        display: inline-block;
    }
    #video {
        display: block;
        width: 100%;        /* fill container */
        height: 100%;       /* fill container */
        object-fit: cover;  /* important! */
        border: 2px solid #ccc;
    }
    #container {
    width: 480px;   /* your desired width */
    height: 480px;  /* your desired height */
    max-width: 100vw;
    max-height: 100vh;
    }
    #overlay {
        position: absolute;
        top: 0;
        left: 0;
        width: 640px;
        height: 480px;
        pointer-events: none;
    }
    button {
        margin: 10px 5px;
        padding: 10px 20px;
    }
    #output {
        margin-top: 20px;
        padding: 10px;
        border: 1px solid #ccc;
        background: #f0f0f0;
        font-family: monospace;
        white-space: pre-wrap;
        max-height: 200px;
        overflow-y: auto;
    }
</style>
</head>
<body>

<div id="container">
    <video id="video"autoplay playsinline muted></video>
    <canvas id="overlay"></canvas>
</div>

<button onclick="startCamera()">Start Camera</button>
<button onclick="stopCamera()">Stop Camera</button>
<button onclick="toggleScan()">Toggle Scan</button>

<div id="output">Align the white corner squares with the green guides...</div>

<script>
const video = document.getElementById('video');
const overlay = document.getElementById('overlay');
const overlayCtx = overlay.getContext('2d');
const output = document.getElementById('output');

let stream = null;
let scanning = false;
let animationId = null;

// Define guide positions (adjust these to match your QR code layout)
const guides = {
    topLeft: { x: 100, y: 80, size: 60 },
    topRight: { x: 480, y: 80, size: 60 },
    bottomLeft: { x: 100, y: 340, size: 60 }
};

async function startCamera() {
    try {
        stream = await navigator.mediaDevices.getUserMedia({ 
            video: { facingMode: 'environment', width: 1280, height: 720 } 
        });
        video.srcObject = stream;
        output.textContent = 'Camera started. Click "Toggle Scan" to begin.';
        drawGuides();
    } catch (err) {
        output.textContent = 'Error accessing camera: ' + err.message;
    }
}

function stopCamera() {
    if (stream) {
        stream.getTracks().forEach(track => track.stop());
        video.srcObject = null;
        scanning = false;
        if (animationId) {
            cancelAnimationFrame(animationId);
        }
        overlayCtx.clearRect(0, 0, overlay.width, overlay.height);
        output.textContent = 'Camera stopped.';
    }
}

function toggleScan() {
    scanning = !scanning;
    if (scanning) {
        output.textContent = 'Scanning...';
        scanFrame();
    } else {
        if (animationId) {
            cancelAnimationFrame(animationId);
        }
        drawGuides();
        output.textContent = 'Scanning paused.';
    }
}

function drawGuides() {
    overlayCtx.clearRect(0, 0, overlay.width, overlay.height);
    
    // Draw semi-transparent guides
    overlayCtx.strokeStyle = 'lime';
    overlayCtx.lineWidth = 3;
    overlayCtx.setLineDash([10, 5]);
    
    overlayCtx.strokeRect(guides.topLeft.x, guides.topLeft.y, guides.topLeft.size, guides.topLeft.size);
    overlayCtx.strokeRect(guides.topRight.x, guides.topRight.y, guides.topRight.size, guides.topRight.size);
    overlayCtx.strokeRect(guides.bottomLeft.x, guides.bottomLeft.y, guides.bottomLeft.size, guides.bottomLeft.size);
    
    // Draw labels
    overlayCtx.setLineDash([]);
    overlayCtx.fillStyle = 'lime';
    overlayCtx.font = '12px Arial';
    overlayCtx.fillText('TL', guides.topLeft.x, guides.topLeft.y - 5);
    overlayCtx.fillText('TR', guides.topRight.x, guides.topRight.y - 5);
    overlayCtx.fillText('BL', guides.bottomLeft.x, guides.bottomLeft.y - 5);
}

function scanFrame() {
    if (!scanning) return;

    // Redraw guides
    drawGuides();

    const canvas = document.createElement('canvas');
    canvas.width = video.videoWidth;
    canvas.height = video.videoHeight;
    const ctx = canvas.getContext('2d');
    
    ctx.drawImage(video, 0, 0);
    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
    
    // Extract grid based on guide positions
    const grid = extractGridFromGuides(imageData);
    
    if (grid) {
        decodeGrid(grid);
    }
    
    animationId = requestAnimationFrame(scanFrame);
}

function extractGridFromGuides(imageData) {
    const SIDE = 128;
    
    // Calculate scale between video display and actual video resolution
    const scaleX = imageData.width / video.clientWidth;
    const scaleY = imageData.height / video.clientHeight;
    
    // Scale guide positions to match actual video resolution
    const topLeft = {
        x: guides.topLeft.x * scaleX,
        y: guides.topLeft.y * scaleY,
        size: guides.topLeft.size * scaleX
    };
    const topRight = {
        x: guides.topRight.x * scaleX,
        y: guides.topRight.y * scaleY,
        size: guides.topRight.size * scaleX
    };
    const bottomLeft = {
        x: guides.bottomLeft.x * scaleX,
        y: guides.bottomLeft.y * scaleY,
        size: guides.bottomLeft.size * scaleX
    };
    
    // Calculate the center of each corner marker
    const tlCenter = { x: topLeft.x + topLeft.size / 2, y: topLeft.y + topLeft.size / 2 };
    const trCenter = { x: topRight.x + topRight.size / 2, y: topRight.y + topRight.size / 2 };
    const blCenter = { x: bottomLeft.x + bottomLeft.size / 2, y: bottomLeft.y + bottomLeft.size / 2 };
    
    // Calculate grid dimensions (assuming square grid)
    const gridWidth = trCenter.x - tlCenter.x;
    const gridHeight = blCenter.y - tlCenter.y;
    
    // Start position (top-left of actual data, accounting for 8x8 marker offset)
    const startX = tlCenter.x;
    const startY = tlCenter.y;
    
    const blockWidth = gridWidth / SIDE;
    const blockHeight = gridHeight / SIDE;
    
    const bits = [];
    
    for (let row = 0; row < SIDE; row++) {
        for (let col = 0; col < SIDE; col++) {
            const x = Math.floor(startX + col * blockWidth);
            const y = Math.floor(startY + row * blockHeight);
            
            if (x >= 0 && x < imageData.width && y >= 0 && y < imageData.height) {
                const i = (y * imageData.width + x) * 4;
                const brightness = (imageData.data[i] + imageData.data[i + 1] + imageData.data[i + 2]) / 3;
                bits.push(brightness < 128 ? '1' : '0');
            } else {
                bits.push('0');
            }
        }
    }
    
    return bits.join('');
}

function decodeGrid(bitString) {
    try {
        // Convert bits to bytes
        const bytes = [];
        for (let i = 0; i < bitString.length; i += 8) {
            const byte = parseInt(bitString.substr(i, 8), 2);
            bytes.push(byte);
        }
        
        // Check magic bytes "B2D1"
        const magic = String.fromCharCode(bytes[0], bytes[1], bytes[2], bytes[3]);
        
        // Extract header
        const total = (bytes[4] << 8) | bytes[5];
        const index = (bytes[6] << 8) | bytes[7];
        const length = (bytes[8] << 8) | bytes[9];
        
        // Extract data
        const chunkData = bytes.slice(10, 10 + length);
        
        // Extract CRC
        const crcStart = 10 + length;
        const crc = (bytes[crcStart] << 24) | (bytes[crcStart + 1] << 16) | 
                    (bytes[crcStart + 2] << 8) | bytes[crcStart + 3];
        
        // Try to decode as text
        let text = '';
        for (let i = 0; i < chunkData.length; i++) {
            const byte = chunkData[i];
            if (byte >= 32 && byte <= 126) {
                text += String.fromCharCode(byte);
            } else {
                text += '.';
            }
        }
        
        output.textContent = 
            'Magic: ' + magic + (magic === 'B2D1' ? ' ✓' : ' ✗') + '\n' +
            'Total chunks: ' + total + '\n' +
            'Current chunk: ' + index + '\n' +
            'Data length: ' + length + '\n' +
            'CRC: 0x' + crc.toString(16).padStart(8, '0') + '\n\n' +
            'Decoded data:\n' + text;
            
    } catch (err) {
        output.textContent = 'Decode error: ' + err.message;
    }
}
</script>

</body>
</html>